# 113 时间格式化

## 题目描述

运维工程师采集到某产品线网运行一天产生的日志`n`条， 现需根据日志时间先后顺序对日志进行排序，日志格式如下：

日志时间格式为 `H:M:S.N`
- `H`表示小时，取值范围是0\~23
- `M`表示分钟，取值范围是0\~59
- `S`表示秒，取值范围是0\~59
- `N`表示毫秒，取值范围是0\~999

时间可能并没有补全，也就是说`01:01:01.001`也可能表示为`1:1:1.1`

## 输入描述

第一行输入一个正数`n`，表示日志条数，取值范围是1 <= n <= 100000。

接下来`n`行输入`n`个时间。

## 输出描述

按时间升序排序之后的时间，如果有两个时间表示的时间相同，则保持输入顺序。

## 示例描述

### 示例一

**输入：**

```text
2
01:41:8.9
1:1:09.211
```

**输出：**

```text
1:1:09.211
01:41:8.9
```

### 示例二

**输入：**

```text
3
23:41:08.023
1:1:09.211
08:01:22.0
```

**输出：**

```text
1:1:09.211
08:01:22.0
23:41:08.023
```

### 示例三

**输入：**

```text
2
22:41:08.023
22:41:08.23
```

**输出：**

```text
22:41:08.023
22:41:08.23
```

**说明：**  

时间相同保持输入顺序

## 解题思路

1. 构建`get_time`函数，将时间转换为毫秒值：
   - 使用`split`方法将时间字符串进行分隔，按`H:M:S.N`提取对应的数值。
   - 计算毫秒值。
2. 对日志时间按照毫秒值进行排序，得到结果。    

## 解题代码

```python
def solve_method(times):
	sorted_times = sorted(times, key=get_time)
	return sorted_times


def get_time(time_str: str):
    time_strs = time_str.split(":")
    h = int(time_strs[0])
    m = int(time_strs[1])
    s = int(time_strs[-1].split('.')[0])
    n = int(time_strs[-1].split('.')[1])
    return h * 60 * 60 * 1000 + m * 60 * 1000 + s * 1000 + n


if __name__ == '__main__':
	assert solve_method(["01:41:8.9","1:1:09.211"]) == ["1:1:09.211","01:41:8.9"]
	assert solve_method(["23:41:08.023","1:1:09.211","08:01:22.0"]) == ["1:1:09.211","08:01:22.0","23:41:08.023"]
	assert solve_method(["22:41:08.023","22:41:08.23"]) == ["22:41:08.023","22:41:08.23"]
```



