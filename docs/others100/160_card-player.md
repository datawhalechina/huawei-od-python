# 160 玩牌高手

## 题目描述

给定一个长度为`N`的整数数组，表示一个选手在`N`轮内选择的牌面分数，选手基于规则选牌，请计算所有轮结束后，其可以获得的最高总分数。

选择规则如下：
1. 在每轮中，选手可以选择获取该轮牌面，则其总分数加上该轮牌面分数为其新的总分数。 
2. 选手也可不选择本轮牌面，直接跳到下一轮，此时将当前总分数还原为3轮前的总分数，若当前轮次小于等于3，则总分数置0。
3. 选手初始总分数为0，且必须依次参加每轮。

## 输入描述

第一行是一个小写逗号分隔的字符串，表示`N`轮的牌面分数，取值范围是1 <= N <= 20，分数值为整数，取值范围是`[-100,100]`。 

## 输出描述

所有轮结束后，选手能获得的最高总分数。

## 示例描述

### 示例一

**输入：**

```text
1,-5,-6,4,3,6,-2
```

**输出：**

```text
11
```

**说明：**

总共7轮牌面：
- 第1轮：选择该轮牌面总分数为1。
- 第2轮：不选择该轮牌面总分数还原为θ。
- 第3轮：不选择该轮牌面总分数还原为0。
- 第4轮：选择该轮牌面总分数为4。
- 第5轮：选择该轮牌面总分数为7。
- 第6轮：选择该轮牌面总分数为13。
- 第7轮：如果不选择该轮牌面，则总分数返回到三轮前的分数，即第四轮的总分数4，如果选择该轮牌面，总分数为11，所以选择该轮。
  
因此最高总分数为11。

## 解题思路

**基本思路：** 使用动态规划求解。

1. 遍历所有轮次，使用动态规划方法：
    - 确定dp数组以及下标的含义：`dp[i]`表示第i轮获得的最大总分数。
    - 确定递推公式：
       - 如果当前轮次小于等于3，则总分数置0，公式为`dp[i]=0`。
       - 如果选择该轮牌面分数，公式为`dp[i] = dp[i - 1] + scores[i - 1]`。
       - 跳过该轮，将当前总分数还原为三轮前的总分数，公式为`dp[i-3]`。
       - 计算两者的最大值，公式为`dp[i] = max(dp[i], dp[i - 3])`。
    - dp数组初始化：将所有元素都初始化为0。
    - 确定遍历顺序：从1到`n+1`遍历。
2. 返回`dp[n]`，即在第`n`轮获得的最高总分数。   

## 解题代码

```python
def solve_method(scores):
    n = len(scores)
    # dp[i]表示第i轮获得的最大总分数
    dp = [0] * (n + 1)

    for i in range(1, n + 1):
        # 如果当前轮次小于等于3，则总分数置0
        if i <= 3:
            dp[i] = 0
        else:
            # 选择获取该轮牌面分数
            dp[i] = dp[i - 1] + scores[i - 1]
        # 跳过该轮，将当前总分数还原为三轮前的总分数
        dp[i] = max(dp[i], dp[i - 3])

    return dp[n]


if __name__ == '__main__':
    assert solve_method([1, -5, -6, 4, 3, 6, -2]) == 11
```

