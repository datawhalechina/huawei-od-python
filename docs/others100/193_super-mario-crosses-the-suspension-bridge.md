# 193 超级玛丽过吊桥

## 题目描述

超级玛丽好不容易来到新的一关，有一个长长的吊桥，吊桥的尽头是下水管道，其中随机的木板存在缺失，一旦踩到就会死亡，死亡后如果还有剩余的生命将在原地复活且不受木板缺失影响，但会消耗一次生命，如果跨过了管道，将跌入悬崖，通关失败。

超级玛丽从起点`S`开始，可以走到下一个木板（计1），也可以跳着跨过一个块（计2）或两个木板（计3），最终必须刚好走到终点`E`。

现在给定超级玛丽当前的生命数`M`，吊桥的长度`N`，缺失的木板数`K`，以及随机缺失的木板编号数组`L`，请帮忙计算一下，超级玛丽有多少种方法可以通过此关。

## 输入描述

第一行是`M N K`，分别表示：
- `M`表示超级玛丽当前生命数，取值范围是1 <= M <= 5。
- `N`表示吊桥的长度，取值范围是1 <= N <= 32。
- `K`表示缺失木板数，取值范围是1 <= K <= N。

第二行是`L`，表示缺失木板编号数组，长度及编号的内容不大于`N`的编号数组，其中1 <= L[i] <= N，由空格分隔的整数数组。

## 输出描述

输出通过此关的吊桥走法个数，如果不能通过此关，请输出0。

## 示例描述

### 示例一

**输入：**

```text
2 2 1
2
```

**输出：**

```text
4
```

**说明：**

2个生命，2个木板，缺失1个木板，其中第2个木板有缺失，一共有4种走法：

1. 直接跳过两个木板，到达终点。
2. 先走一步，然后再跳过一个木板，到达终点。
3. 先走一步，再走一步，掉进陷阱，死亡之后复活，再走一步，到达终点。
4. 先跳过一个木板，掉进陷阱，死亡之后复活，再走一步，到达终点。

### 示例二

**输入：**

```text
1 3 2
1 3
```

**输出：**

```text
1
```

**说明：**

1个生命，3个木板，缺失2个木板，第1、3个木板有缺失，只有1种走法，其他都不能通关。

具体走法：跳过一个木板，再跳过一个木板，可以正好抵达终点。

### 示例三

**输入：**

```text
3 10 2
4 7
```

**输出：**

```text
504
```

## 解题思路

**基本思路：** 使用动态规划方法求解。

1. 使用动态规划方法：
    - 确定`dp`数组以及下标的含义：`dp[i][j]`表示走到第`i`个位置时，此时生命值为`j`时的走法数。
    - 确定递推公式：
       - 如果下一个木板是陷阱，损失一次生命，加上三种走法，公式为`dp[i][j] = dp[i - 1][j + 1] + dp[i - 2][j + 1] + dp[i - 3][j + 1]`。
       - 如果下一个木板是正常的，不损失生命，加上三种走法，公式为`dp[i][j] = dp[i - 1][j] + dp[i - 2][j] + dp[i - 3][j]`。
    - `dp`数组初始化：当在初始位置时，生命值为`M`，走法数为1，则`dp[0][M] = 1`，其他值都为0。
    - 确定遍历顺序：`i`从1到`N+2`遍历，`j`从0到`M+1`。
2. 去掉生命值为0的次数，计算生命值从1开始到`M`的数组元素和，即为到达终点的总走法。    

## 解题代码

```python
def solve_method(M, N, K, L):
    """
    :param M: 超级玛丽当前的生命数
    :param N: 吊桥的长度
    :param K: 缺失木板数
    :param L: 缺失木板编号数组
    :return: 通过此关的吊桥走法个数
    """

    # dp[i][j]表示走到第i个位置时，此时生命值为j时的走法数
    dp = [[0 for _ in range(M + 1)] for _ in range(N + 2)]
    # 当在初始位置时，生命值为M，走法数为1
    dp[0][M] = 1

    # 遍历每一个位置
    for i in range(1, N + 2):
        # 寻找生命值从0到M的走法
        for j in range(M + 1):
            # 如果遇到陷阱，（该步已经扣除了一次生命值）则从上一个j+1的生命值累加
            if i in L:
                # 循环中的j最大为m，而推导式中有j+1，所以j最大为m-1
                if j < M:
                    # 损失一次生命，加上三种走法
                    dp[i][j] = dp[i - 1][j + 1] + dp[i - 2][j + 1] + dp[i - 3][j + 1]
            else:
                # 没有陷阱，不损失生命，加上三种走法
                dp[i][j] = dp[i - 1][j] + dp[i - 2][j] + dp[i - 3][j]

    # 去掉第一列生命值为0的次数，生命值从1开始到M，求和总次数
    return sum(dp[N + 1][1:])


if __name__ == "__main__":
    assert solve_method(2, 2, 1, [2]) == 4
    assert solve_method(1, 3, 2, [1, 3]) == 1
    assert solve_method(3, 10, 2, [4, 7]) == 504
```

