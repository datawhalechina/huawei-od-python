# 012 判断字符串子序列

## 题目描述

给定字符串`target`和`source`，判断`target`是否为`source`的子序列。

你可以认为`target`和`source`中仅包含英文小写字母。字符串`source`可能会很长（长度约为500000），而`target`是个短字符串（长度小于等于100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如：`abc`是`aebycd`的一个子序列，而`ayb`不是）。

请找出最后一个子序列的起始位置。

## 输入描述

第一行是`target`，短字符串（长度 <= 100）。

第二行是`source`，长字符串（长度约等于500000）。

## 输出描述

最后一个子序列的起始位置，即最后一个子序列首字母的下标，如果找不到，则输出-1。

## 示例描述

### 示例一

**输入：**
```text
abc
abcaybec
```

**输出：**
```text
3
```

**说明：**  

这里有两个`abc`的子序列满足，取下标较大的，故返回3。

## 解题思路

**基本思路：** 使用双指针法求解。

1. 初始化双指针，分别指向`target`的尾元素、`source`的尾元素。
2. 由于获取下标较大的位置，则从后向前遍历：
    - 当两个指针指向的字母相同时，则指针向左移动，继续遍历。
    - 当遍历得到第一个子序列，则可以返回当前下标。
3. 如果找不到子序列，则返回-1。    

## 解题代码

```python
def solve_method(target, source):
    t_pos = len(target) - 1
    s_pos = len(source) - 1

    # 由于获取下标较大的位置，则从后向前遍历
    while t_pos >= 0 and s_pos >= 0:
        if target[t_pos] == source[s_pos]:
            t_pos -= 1
            if t_pos < 0:
                # 当遍历得到第一个子序列，则可以返回当前下标
                return s_pos

        s_pos -= 1

    return -1


if __name__ == '__main__':
    assert solve_method("abc", "abcaybec") == 3
```